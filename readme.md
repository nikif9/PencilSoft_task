# Задача №3 (SQL)
Имеется база со следующими таблицами:
```sql
CREATE TABLE `users` (
    `id`         INT(11) NOT NULL AUTO_INCREMENT,
    `name`       VARCHAR(255) DEFAULT NULL,
    `gender`     INT(11) NOT NULL COMMENT '0 - не указан, 1 - мужчина, 2 - женщина.',
    `birth_date` INT(11) NOT NULL COMMENT 'Дата в unixtime.',
    PRIMARY KEY (`id`)
);
CREATE TABLE `phone_numbers` (
    `id`      INT(11) NOT NULL AUTO_INCREMENT,
    `user_id` INT(11) NOT NULL,
    `phone`   VARCHAR(255) DEFAULT NULL,
    PRIMARY KEY (`id`)
);
```
# решение 

Давайте начнем с оптимизации таблиц. Для этого мы добавим индексы, которые могут ускорить процесс выборки.

```sql
CREATE INDEX idx_users_gender_birth_date ON users(gender, birth_date);
CREATE INDEX idx_phone_numbers_user_id ON phone_numbers(user_id);
```
Индекс idx_users_gender_birth_date позволит нам быстро отфильтровать женщин в нужном возрастном диапазоне. Индекс idx_phone_numbers_user_id ускорит соединение двух таблиц.

Теперь перейдем к написанию запроса. Перед этим мы должны учесть, что возраст определяется как разница между текущей датой и датой рождения. В SQL мы можем использовать функцию UNIX_TIMESTAMP(), которая возвращает текущую дату и время в формате unixtime.
```sql
SELECT 
    u.name, COUNT(pn.phone) AS phone_count
FROM 
    users u 
JOIN 
    phone_numbers pn ON u.id = pn.user_id
WHERE 
    u.gender = 2
    AND ((UNIX_TIMESTAMP() - u.birth_date) / 60 / 60 / 24 / 365) BETWEEN 18 AND 22
GROUP BY 
    u.id;
```
В этом запросе мы:

1.Присоединяем таблицу phone_numbers по user_id.
2.Фильтруем только женщин (пол = 2).
3.Вычисляем возраст и проверяем, что он находится в диапазоне от 18 до 22 лет.
4.Группируем результаты по id пользователя, чтобы получить количество телефонных номеров для каждого пользователя.

# Задача №4 (Оптимизация)
Проведите рефакторинг, исправьте баги и прокомментируйте код, приведённый ниже
```php
function load_users_data($user_ids) {
    $user_ids = explode(',', $user_ids);
    foreach ($user_ids as $user_id) {
        $db = mysqli_connect("localhost", "root", "123123", "database");
        $sql = mysqli_query($db, "SELECT * FROM users WHERE id=$user_id");
        while($obj = $sql->fetch_object()){
            $data[$user_id] = $obj->name;
        }
        mysqli_close($db);
    }
    return $data;
}
// Как правило, в $_GET['user_ids'] должна приходить строка
// с номерами пользователей через запятую, например: 1,2,17,48
$data = load_users_data($_GET['user_ids']);
foreach ($data as $user_id=>$name) {
    echo "<a href=\"/show_user.php?id=$user_id\">$name</a>";
}
```
# решение 
В исходной реализации кода есть несколько минусов, которые можно улучшить:

1.Небезопасное использование пользовательского ввода: В исходном коде передается значение $_GET['user_ids'] напрямую в SQL-запрос без проверки и фильтрации. Это может привести к SQL-инъекциям, когда злоумышленник может изменить запрос таким образом, чтобы получить несанкционированный доступ к данным или испортить базу данных. Для безопасности следует использовать подготовленные выражения или функции фильтрации входных данных, такие как mysqli_real_escape_string().

2.Открытие и закрытие соединения с базой данных внутри цикла: В каждой итерации цикла происходит открытие и закрытие соединения с базой данных. Это ненадежный подход и может привести к проблемам с производительностью, особенно при обработке большого количества пользователей. Рекомендуется открыть соединение с базой данных до начала цикла и закрыть его после завершения цикла.

3.Избыточное выполнение запросов: В коде происходит выполнение запроса к базе данных для каждого пользователя из списка $user_ids. Это может быть неэффективно, особенно если в списке есть повторяющиеся значения. Лучше получить данные всех пользователей за один запрос, используя оператор IN или подготовленные выражения.

4.Отсутствие проверки наличия данных: В исходном коде нет проверки наличия данных в результате выполнения SQL-запроса. Если запрос не вернет результатов, то переменная $data не будет определена, что может привести к ошибке при использовании ее в дальнейшем.

5.Неструктурированный код: Исходный код не имеет должной структуры и отступов, что затрудняет его чтение и понимание. Это усложняет поддержку и разработку.

Ниже приведен улучшенный код с комментариями:
```php
<?php

function load_users_data($user_ids) {
    $data = []; // Создаем пустой массив для хранения данных

    $user_ids = explode(',', $user_ids);

    // Подключение к базе данных выполняется один раз до начала цикла
    $dsn = "mysql:host=localhost;dbname=database";
    $username = "root";
    $password = "123123";

    try {
        $pdo = new PDO($dsn, $username, $password);
        // Устанавливаем атрибуты для PDO, чтобы получать ассоциативные массивы
        $pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
        $pdo->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);

        // Группируем идентификаторы пользователей для выполнения одного запроса
        $placeholders = rtrim(str_repeat('?,', count($user_ids)), ',');

        // Подготовка запроса с подставляемыми параметрами
        $stmt = $pdo->prepare("SELECT id, name FROM users WHERE id IN ($placeholders)");

        // Выполнение запроса с передачей массива идентификаторов в качестве параметров
        $stmt->execute($user_ids);

        // Извлекаем данные по одной строке за раз и сохраняем их в массив $data
        while ($row = $stmt->fetch()) {
            $data[$row['id']] = $row['name'];
        }

        // Закрываем соединение с базой данных
        $pdo = null;

    } catch (PDOException $e) {
        // Обработка ошибок при подключении или выполнении запроса
        die("Ошибка: " . $e->getMessage());
    }

    return $data;
}

// Как правило, в $_GET['user_ids'] должна приходить строка
// с номерами пользователей через запятую, например: 1,2,17,48
$data = load_users_data($_GET['user_ids']);

foreach ($data as $user_id => $name) {
    // Для безопасности применяем функцию urlencode() для идентификатора пользователя
    $user_id_safe = urlencode($user_id);
    echo "<a href=\"/show_user.php?id=$user_id_safe\">$name</a>";
}
```
В улучшенной версии мы использовали PDO для подключения к базе данных и выполнения запроса с подготовленными выражениями. Это обеспечивает безопасность и эффективность при работе с базой данных. Открываем соединение с базой данных один раз перед выполнением запроса и закрываем его после завершения.